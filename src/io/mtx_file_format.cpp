#include "taco/io/mtx_file_format.h"

#include <iostream>
#include <sstream>
#include <cstdlib>
#include <climits>

#include "taco/tensor_base.h"
#include "taco/util/error.h"
#include "taco/util/strings.h"
#include "taco/util/timers.h"

using namespace std;

namespace taco {
namespace io {
namespace mtx {

void readFile(std::ifstream &mtxfile, int blockSize,
              int* nrow, int* ncol, int* nnzero,
              TensorBase* tensor) {

  std::string line;
  int rowind,colind;
  double value;
  std::string val;
  while(std::getline(mtxfile,line)) {
    std::stringstream iss(line);
    char firstChar;
    iss >> firstChar;
    // Skip comments
    if (firstChar != '%') {
      iss.clear();
      iss.str(line);
      iss >> *nrow >> *ncol >> *nnzero;
      break;
    }
  }

  if (blockSize == 1) {
    while(std::getline(mtxfile,line)) {
      std::stringstream iss(line);
      iss >> rowind >> colind >> val;
      value = std::stod(val);
      if (value != 0.0)
        tensor->insert({rowind-1,colind-1},value);
    }
  }
  else {
    while(std::getline(mtxfile,line)) {
      std::stringstream iss(line);
      iss >> rowind >> colind >> val;
      value = std::stod(val);
      if (value != 0.0)
        tensor->insert({(rowind-1)/blockSize, (colind-1)/blockSize,
                        (rowind-1)%blockSize, (colind-1)%blockSize},value);
    }
  }

  tensor->pack();
}

void writeFile(std::ofstream &mtxfile, std::string name,
               const std::vector<int> dimensions, int nnzero) {
  mtxfile << "%-----------------------------------" << std::endl;
  mtxfile << "% MTX matrix file generated by taco " << std::endl;
  mtxfile << "% name: " << name << std::endl;
  mtxfile << "%-----------------------------------" << std::endl;
  for (size_t i=0; i<dimensions.size(); i++) {
    mtxfile << dimensions[i] << " " ;
  }
  mtxfile << " " << nnzero << std::endl;
}

TensorBase readFile(std::ifstream& file, std::string name) {
  util::LapTimer timer("mtx readFile");

  string line;
  if (!std::getline(file, line)) {
    return TensorBase();
  }

  timer.start("read file");

  // Skip comments at the top of the file
  string token;
  do {
    std::stringstream lineStream(line);
    lineStream >> token;
    if (token[0] != '%') {
      break;
    }
  } while (std::getline(file, line));

  // The first non-comment line is the header with dimension sizes and nnz
  char* linePtr = (char*)line.data();
  size_t rows = strtoul(linePtr, &linePtr, 10);
  size_t cols = strtoul(linePtr, &linePtr, 10);
  size_t nnz = strtoul(linePtr, &linePtr, 10);
  taco_uassert(rows <= INT_MAX) << "Number of rows in file exceeds INT_MAX";
  taco_uassert(cols <= INT_MAX) << "Number of columns in file exceeds INT_MAX";
  taco_uassert(nnz <= INT_MAX) << "Number of non-zeros in file exceeds INT_MAX";

  vector<int> coordinates;
  vector<double> values;
  coordinates.reserve(nnz*2);
  values.reserve(nnz);

  while (std::getline(file, line)) {
    linePtr = (char*)line.data();
    long rowIdx = strtol(linePtr, &linePtr, 10);
    long colIdx = strtol(linePtr, &linePtr, 10);
    double val = strtod(linePtr, &linePtr);
    taco_uassert(rowIdx <= INT_MAX && colIdx <= INT_MAX) <<
        "Coordinate in file is larger than INT_MAX";

    coordinates.push_back(rowIdx);
    coordinates.push_back(colIdx);
    values.push_back(val);
  }

  timer.lap("initialize tensor");
  TensorBase tensor(name, ComponentType::Double, {(int)rows,(int)cols});
  tensor.reserve(nnz);

  // Insert coordinates
  for (size_t i = 0; i < values.size(); i++) {
    tensor.insert({coordinates[i*2], coordinates[i*2+1]}, values[i]);
  }

  timer.stop();

  return tensor;
}


}}}
